name: Release et Rotation des Branches

on:
  pull_request:
    types:
      - closed
    branches:
      - main

permissions:
  contents: write
  pull-requests: read

jobs:
  release_and_rotate:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout du code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configuration de Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Traitement complet
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 1. RÃ‰CUPÃ‰RATION DE LA BRANCHE FUSIONNÃ‰E
          MERGED_BRANCH="${{ github.event.pull_request.head.ref }}"
          if [[ ! "$MERGED_BRANCH" =~ ^v?[0-9] ]]; then
            echo "La branche $MERGED_BRANCH n'est pas une version. ArrÃªt."
            exit 0
          fi

          # 2. CRÃ‰ATION DE LA RELEASE (TAG)
          TAG_NAME="$MERGED_BRANCH"
          [[ "$TAG_NAME" != v* ]] && TAG_NAME="v$TAG_NAME"
          echo "CrÃ©ation de la Release : $TAG_NAME"
          gh release create "$TAG_NAME" --title "Version $TAG_NAME" --generate-notes --target main

          # 3. LECTURE / CALCUL DE LA NOUVELLE BRANCHE (N)
          if [ -f "NEXT_VERSION.txt" ]; then
            NEW_BRANCH=$(cat NEXT_VERSION.txt | tr -d '[:space:]')
          fi

          if [[ -z "$NEW_BRANCH" || "$NEW_BRANCH" == "$MERGED_BRANCH" ]]; then
            echo "ðŸ‘‰ Mode Auto-incrÃ©mentation."
            VERSION_CLEAN="${MERGED_BRANCH#v}"
            MAJOR="${VERSION_CLEAN%%.*}"
            MINOR="${VERSION_CLEAN##*.}"
            NEW_MINOR=$((MINOR + 1))
            NEW_BRANCH="$([[ "$MERGED_BRANCH" == v* ]] && echo "v")${MAJOR}.${NEW_MINOR}"
          fi

          # 4. CRÃ‰ATION DE LA NOUVELLE BRANCHE (N)
          git fetch origin main
          git checkout -B main origin/main
          git checkout -b "$NEW_BRANCH"
          git push origin "$NEW_BRANCH"

          # 5. NETTOYAGE (SUPRESSION N-2 ET INFÃ‰RIEUR)
          echo "ðŸ§¹ DÃ©but du nettoyage..."
          
          # On force un fetch complet de toutes les branches pour que le runner 'voie' tout
          git fetch --all --prune
          
          # On liste les branches distantes, on nettoie proprement le texte 'origin/' 
          # et on ne garde que ce qui ressemble Ã  une version (ex: v1.1 ou 1.1)
          RAW_LIST=$(git branch -r | sed 's|.*origin/||' | grep -E "^v?[0-9]" | grep -vE "^main$|^master$")
          
          # Tri par version dÃ©croissante (v1.3, v1.2, v1.1...)
          BRANCHES=$(echo "$RAW_LIST" | sort -rV)
          BRANCH_ARRAY=($BRANCHES)
          
          echo "Liste triÃ©e des branches de version sur le serveur :"
          echo "${BRANCH_ARRAY[@]}"

          # i=0 (N), i=1 (N-1). On supprime tout Ã  partir de i=2 (N-2)
          if [ ${#BRANCH_ARRAY[@]} -gt 2 ]; then
            for (( i=2; i<${#BRANCH_ARRAY[@]}; i++ )); do
              TO_DELETE="${BRANCH_ARRAY[$i]}"
              echo "ðŸ—‘ï¸ Suppression de l'ancienne branche (N-2+) : $TO_DELETE"
              git push origin --delete "$TO_DELETE"
            done
          else
            echo "âœ… Rien Ã  supprimer. On garde : ${BRANCH_ARRAY[*]}"
          fi